import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';
import { auditLogger } from '@/lib/audit-logger';
import { recalculateImageRiskScores } from '@/lib/scan-aggregations-server';

const CveClassificationSchema = z.object({
  cveId: z.string().min(1, 'CVE ID is required'),
  isFalsePositive: z.boolean().optional().default(false),
  comment: z.string().optional(),
  createdBy: z.string().optional(),
});

interface RouteParams {
  params: Promise<{ name: string }>;
}

export async function GET(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const { name: imageName } = await params;

    // Get all images with this name (all tags)
    const images = await prisma.image.findMany({
      where: {
        name: imageName,
      },
    });

    if (images.length === 0) {
      return NextResponse.json([]);
    }

    // Get classifications for all imageIds and consolidate by CVE ID
    const imageIds = images.map(img => img.id);
    const allClassifications = await prisma.cveClassification.findMany({
      where: {
        imageId: {
          in: imageIds,
        },
      },
      include: {
        imageVulnerability: {
          include: {
            vulnerability: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    // Consolidate by CVE ID (latest classification wins)
    const consolidatedMap = new Map();
    allClassifications.forEach(classification => {
      const cveId = classification.imageVulnerability?.vulnerability?.cveId;
      if (cveId) {
        const existing = consolidatedMap.get(cveId);
        if (!existing || new Date(classification.updatedAt) > new Date(existing.updatedAt)) {
          consolidatedMap.set(cveId, classification);
        }
      }
    });

    const consolidated = Array.from(consolidatedMap.values());
    return NextResponse.json(consolidated);
  } catch (error) {
    console.error('Error fetching CVE classifications for image name:', error);
    return NextResponse.json(
      { error: 'Failed to fetch CVE classifications' },
      { status: 500 }
    );
  }
}

export async function POST(
  request: NextRequest,
  { params }: RouteParams
) {
  try {
    const { name: imageName } = await params;
    const body = await request.json();

    const validatedData = CveClassificationSchema.parse(body);

    // Get all images with this name (all tags)
    const images = await prisma.image.findMany({
      where: {
        name: imageName,
      },
    });

    if (images.length === 0) {
      return NextResponse.json(
        { error: 'No images found with this name' },
        { status: 404 }
      );
    }

    // Find or create vulnerability
    let vulnerability = await prisma.vulnerability.findUnique({
      where: { cveId: validatedData.cveId }
    });
    
    if (!vulnerability) {
      // Create vulnerability if it doesn't exist
      vulnerability = await prisma.vulnerability.create({
        data: {
          cveId: validatedData.cveId,
          severity: 'INFO', // Default severity, should be updated later
          title: `Vulnerability ${validatedData.cveId}`,
          description: `Vulnerability classification for ${validatedData.cveId}`,
        }
      });
    }

    const results = [];
    
    // For each image with this name, create/update CVE classification
    for (const image of images) {
      // Find or create ImageVulnerability relationship
      let imageVulnerability = await prisma.imageVulnerability.findFirst({
        where: {
          imageId: image.id,
          vulnerabilityId: vulnerability.id
        }
      });
      
      if (!imageVulnerability) {
        // Create ImageVulnerability if it doesn't exist
        imageVulnerability = await prisma.imageVulnerability.create({
          data: {
            imageId: image.id,
            vulnerabilityId: vulnerability.id,
            packageName: 'unknown', // Would need to be provided in request
            installedVersion: 'unknown',
          }
        });
      }
      
      // Create or update CVE classification
      const existingClassification = await prisma.cveClassification.findFirst({
        where: {
          imageVulnerabilityId: imageVulnerability.id,
          imageId: image.id
        }
      });
      
      let classification;
      if (existingClassification) {
        classification = await prisma.cveClassification.update({
          where: { id: existingClassification.id },
          data: {
            isFalsePositive: validatedData.isFalsePositive,
            comment: validatedData.comment,
            createdBy: validatedData.createdBy,
            updatedAt: new Date()
          }
        });
      } else {
        classification = await prisma.cveClassification.create({
          data: {
            imageVulnerabilityId: imageVulnerability.id,
            imageId: image.id,
            isFalsePositive: validatedData.isFalsePositive,
            comment: validatedData.comment,
            createdBy: validatedData.createdBy,
          }
        });
      }
      
      results.push(classification);
    }

    // Log the classification action
    await auditLogger.cveClassification(
      request,
      validatedData.cveId,
      imageName,
      validatedData.isFalsePositive,
      validatedData.comment
    );

    // Recalculate risk scores for affected images
    try {
      for (const image of images) {
        await recalculateImageRiskScores(image.id);
      }
    } catch (error) {
      console.warn('Failed to recalculate risk scores:', error);
      // Don't fail the request if risk score calculation fails
    }

    return NextResponse.json({
      message: `CVE classification created/updated for ${results.length} images`,
      classifications: results,
      affectedImages: images.length
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.issues },
        { status: 400 }
      );
    }

    console.error('Error creating CVE classification for image name:', error);
    return NextResponse.json(
      { error: 'Failed to create CVE classification' },
      { status: 500 }
    );
  }
}