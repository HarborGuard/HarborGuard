import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';
import type { 
  ScanVulnerabilityFinding,
  TrivyVulnerability,
  GrypeVulnerability,
  PatchStatus
} from '@/generated/prisma';

export interface PatchAnalysis {
  scanId: string;
  imageId: string;
  totalVulnerabilities: number;
  patchableVulnerabilities: number;
  notPatchableVulnerabilities: number;
  patchableByManager: Record<string, number>;
  criticalPatchable: number;
  highPatchable: number;
  mediumPatchable: number;
  lowPatchable: number;
  vulnerabilities: VulnerabilityPatchInfo[];
}

export interface VulnerabilityPatchInfo {
  cveId: string;
  severity: string;
  packageName: string;
  currentVersion: string;
  fixedVersion?: string;
  packageManager?: string;
  isPatchable: boolean;
  patchStatus: PatchStatus;
  reason?: string;
  sources: string[];
}

export class VulnerabilityAnalyzer {
  
  async analyzeScanForPatching(scanId: string): Promise<PatchAnalysis> {
    logger.info(`Analyzing scan ${scanId} for patchability`);
    
    // Get scan with all vulnerability findings
    const scan = await prisma.scan.findUnique({
      where: { id: scanId },
      include: {
        image: true,
        vulnerabilityFindings: true,
        metadata: {
          include: {
            trivyResult: {
              include: {
                vulnerabilities: true
              }
            },
            grypeResult: {
              include: {
                vulnerabilities: true
              }
            }
          }
        }
      }
    });

    if (!scan) {
      throw new Error(`Scan ${scanId} not found`);
    }

    // Analyze each vulnerability for patchability
    const vulnerabilityMap = new Map<string, VulnerabilityPatchInfo>();
    
    // Process normalized vulnerability findings
    for (const finding of scan.vulnerabilityFindings) {
      const key = `${finding.cveId}-${finding.packageName}`;
      
      if (!vulnerabilityMap.has(key)) {
        const patchInfo = this.analyzeVulnerability(finding);
        vulnerabilityMap.set(key, patchInfo);
      } else {
        // Add source if not already present
        const existing = vulnerabilityMap.get(key)!;
        if (!existing.sources.includes(finding.source)) {
          existing.sources.push(finding.source);
        }
        // Update to use fixed version if available
        if (finding.fixedVersion && !existing.fixedVersion) {
          existing.fixedVersion = finding.fixedVersion;
          existing.isPatchable = true;
          existing.patchStatus = 'PATCHABLE';
        }
      }
    }

    // Also process Trivy results for additional details
    if (scan.metadata?.trivyResult?.vulnerabilities) {
      for (const vuln of scan.metadata.trivyResult.vulnerabilities) {
        const key = `${vuln.vulnerabilityId}-${vuln.pkgName}`;
        
        if (!vulnerabilityMap.has(key)) {
          const patchInfo = this.analyzeTrivyVulnerability(vuln);
          vulnerabilityMap.set(key, patchInfo);
        } else {
          const existing = vulnerabilityMap.get(key)!;
          if (vuln.fixedVersion && !existing.fixedVersion) {
            existing.fixedVersion = vuln.fixedVersion;
            existing.isPatchable = true;
            existing.patchStatus = 'PATCHABLE';
          }
        }
      }
    }

    // Also process Grype results
    if (scan.metadata?.grypeResult?.vulnerabilities) {
      for (const vuln of scan.metadata.grypeResult.vulnerabilities) {
        const key = `${vuln.vulnerabilityId}-${vuln.packageName}`;
        
        if (!vulnerabilityMap.has(key)) {
          const patchInfo = this.analyzeGrypeVulnerability(vuln);
          vulnerabilityMap.set(key, patchInfo);
        } else {
          const existing = vulnerabilityMap.get(key)!;
          if (vuln.fixedVersions && !existing.fixedVersion) {
            const fixedVersions = vuln.fixedVersions as string[];
            if (fixedVersions.length > 0) {
              existing.fixedVersion = fixedVersions[0];
              existing.isPatchable = true;
              existing.patchStatus = 'PATCHABLE';
            }
          }
        }
      }
    }

    // Convert map to array and calculate statistics
    const vulnerabilities = Array.from(vulnerabilityMap.values());
    const patchable = vulnerabilities.filter(v => v.isPatchable);
    const notPatchable = vulnerabilities.filter(v => !v.isPatchable);

    // Count by package manager
    const patchableByManager: Record<string, number> = {};
    for (const vuln of patchable) {
      if (vuln.packageManager) {
        patchableByManager[vuln.packageManager] = (patchableByManager[vuln.packageManager] || 0) + 1;
      }
    }

    // Count by severity
    const countBySeverity = (vulns: VulnerabilityPatchInfo[], severity: string) => 
      vulns.filter(v => v.severity.toUpperCase() === severity).length;

    const analysis: PatchAnalysis = {
      scanId,
      imageId: scan.imageId,
      totalVulnerabilities: vulnerabilities.length,
      patchableVulnerabilities: patchable.length,
      notPatchableVulnerabilities: notPatchable.length,
      patchableByManager,
      criticalPatchable: countBySeverity(patchable, 'CRITICAL'),
      highPatchable: countBySeverity(patchable, 'HIGH'),
      mediumPatchable: countBySeverity(patchable, 'MEDIUM'),
      lowPatchable: countBySeverity(patchable, 'LOW'),
      vulnerabilities
    };

    // Update patch status in database for all analyzed vulnerabilities
    await this.updatePatchStatuses(scan.imageId, vulnerabilities);

    return analysis;
  }

  private analyzeVulnerability(finding: ScanVulnerabilityFinding): VulnerabilityPatchInfo {
    const isPatchable = !!finding.fixedVersion && 
                       finding.fixedVersion !== 'unknown' &&
                       finding.fixedVersion !== '';
    
    const packageManager = this.detectPackageManager(finding.packageType);
    
    return {
      cveId: finding.cveId,
      severity: finding.severity,
      packageName: finding.packageName,
      currentVersion: finding.installedVersion || 'unknown',
      fixedVersion: finding.fixedVersion || undefined,
      packageManager,
      isPatchable,
      patchStatus: isPatchable ? 'PATCHABLE' : 'NOT_PATCHABLE',
      reason: !isPatchable ? 'No fixed version available' : undefined,
      sources: [finding.source]
    };
  }

  private analyzeTrivyVulnerability(vuln: TrivyVulnerability): VulnerabilityPatchInfo {
    const isPatchable = !!vuln.fixedVersion && 
                       vuln.fixedVersion !== 'unknown' &&
                       vuln.fixedVersion !== '';
    
    const packageManager = this.detectPackageManager(vuln.targetType);
    
    return {
      cveId: vuln.vulnerabilityId,
      severity: vuln.severity,
      packageName: vuln.pkgName,
      currentVersion: vuln.installedVersion || 'unknown',
      fixedVersion: vuln.fixedVersion || undefined,
      packageManager,
      isPatchable,
      patchStatus: isPatchable ? 'PATCHABLE' : 'NOT_PATCHABLE',
      reason: !isPatchable ? 'No fixed version available' : undefined,
      sources: ['trivy']
    };
  }

  private analyzeGrypeVulnerability(vuln: GrypeVulnerability): VulnerabilityPatchInfo {
    const fixedVersions = vuln.fixedVersions as string[] | null;
    const isPatchable = !!fixedVersions && fixedVersions.length > 0;
    
    const packageManager = this.detectPackageManager(vuln.packageType);
    
    return {
      cveId: vuln.vulnerabilityId,
      severity: vuln.severity,
      packageName: vuln.packageName,
      currentVersion: vuln.packageVersion || 'unknown',
      fixedVersion: fixedVersions?.[0] || undefined,
      packageManager,
      isPatchable,
      patchStatus: isPatchable ? 'PATCHABLE' : 'NOT_PATCHABLE',
      reason: !isPatchable ? 'No fixed version available' : undefined,
      sources: ['grype']
    };
  }

  private detectPackageManager(packageType?: string | null): string | undefined {
    if (!packageType) return undefined;
    
    const typeToManager: Record<string, string> = {
      // Debian/Ubuntu
      'deb': 'apt',
      'debian': 'apt',
      'ubuntu': 'apt',
      'dpkg': 'apt',
      
      // RedHat/CentOS/Fedora
      'rpm': 'yum',
      'rhel': 'yum',
      'centos': 'yum',
      'fedora': 'yum',
      'rpmdb': 'yum',
      
      // Alpine
      'apk': 'apk',
      'alpine': 'apk',
      'apkdb': 'apk',
      
      // Language-specific
      'npm': 'npm',
      'node': 'npm',
      'nodejs': 'npm',
      'python': 'pip',
      'pip': 'pip',
      'pypi': 'pip',
      'gem': 'gem',
      'ruby': 'gem',
      'rubygems': 'gem',
      'go': 'go',
      'go-module': 'go',
      'golang': 'go',
      'java': 'maven',
      'maven': 'maven',
      'jar': 'maven',
      
      // Container/OS packages
      'os-pkgs': this.detectOSPackageManager(packageType),
      'lang-pkgs': undefined, // Need more context
    };
    
    const manager = typeToManager[packageType.toLowerCase()];
    return manager !== undefined ? manager : undefined;
  }

  private detectOSPackageManager(packageType: string): string | undefined {
    // This would need to be enhanced with actual OS detection
    // For now, return undefined to indicate we need more context
    return undefined;
  }

  private async updatePatchStatuses(
    imageId: string, 
    vulnerabilities: VulnerabilityPatchInfo[]
  ): Promise<void> {
    try {
      // Update patch status for each vulnerability
      for (const vuln of vulnerabilities) {
        await prisma.imageVulnerability.updateMany({
          where: {
            imageId,
            vulnerability: {
              cveId: vuln.cveId
            },
            packageName: vuln.packageName
          },
          data: {
            patchStatus: vuln.patchStatus
          }
        });
      }
      
      logger.info(`Updated patch statuses for ${vulnerabilities.length} vulnerabilities`);
    } catch (error) {
      logger.error('Failed to update patch statuses:', error);
      // Non-critical error, continue execution
    }
  }

  async getPatchHistory(imageId: string): Promise<any[]> {
    const operations = await prisma.patchOperation.findMany({
      where: {
        OR: [
          { sourceImageId: imageId },
          { patchedImageId: imageId }
        ]
      },
      include: {
        sourceImage: true,
        patchedImage: true,
        patchResults: true
      },
      orderBy: { startedAt: 'desc' }
    });

    return operations;
  }

  async getLatestPatchAnalysis(imageId: string): Promise<PatchAnalysis | null> {
    // Find the most recent scan for this image
    const latestScan = await prisma.scan.findFirst({
      where: { 
        imageId,
        status: 'SUCCESS'
      },
      orderBy: { startedAt: 'desc' }
    });

    if (!latestScan) {
      return null;
    }

    return this.analyzeScanForPatching(latestScan.id);
  }
}